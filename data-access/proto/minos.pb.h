// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minos.proto

#ifndef PROTOBUF_minos_2eproto__INCLUDED
#define PROTOBUF_minos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace baidu {
namespace minos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_minos_2eproto();
void protobuf_AssignDesc_minos_2eproto();
void protobuf_ShutdownFile_minos_2eproto();

class PbRecordHeader;
class PbRecord;
class UserAccountMessage;
class BrokerResponse;
class SubscribeRecordRequest;
class SubscribeRecordResponse;
class InitSubscriberBrokerRequest;
class InitSubscriberBrokerResponse;
class UninitSubscriberBrokerRequest;
class PartitionProgress;
class PartitionGroupProgress;
class SetPartitionGroupProgressRequest;
class GetPartitionGroupProgressRequest;
class GetPartitionGroupProgressResponse;

enum BrokerResponse_Status {
  BrokerResponse_Status_SUCCEED = 1,
  BrokerResponse_Status_FAILED = 2
};
bool BrokerResponse_Status_IsValid(int value);
const BrokerResponse_Status BrokerResponse_Status_Status_MIN = BrokerResponse_Status_SUCCEED;
const BrokerResponse_Status BrokerResponse_Status_Status_MAX = BrokerResponse_Status_FAILED;
const int BrokerResponse_Status_Status_ARRAYSIZE = BrokerResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* BrokerResponse_Status_descriptor();
inline const ::std::string& BrokerResponse_Status_Name(BrokerResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    BrokerResponse_Status_descriptor(), value);
}
inline bool BrokerResponse_Status_Parse(
    const ::std::string& name, BrokerResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BrokerResponse_Status>(
    BrokerResponse_Status_descriptor(), name, value);
}
enum SubscribeRecordResponse_Status {
  SubscribeRecordResponse_Status_SUCCEED = 1,
  SubscribeRecordResponse_Status_NO_DATA_LEFT = 2,
  SubscribeRecordResponse_Status_RECORD_ID_TOO_SMALL = 3,
  SubscribeRecordResponse_Status_NO_SUCH_PARTITION_GROUP = 4,
  SubscribeRecordResponse_Status_FAILED = 99
};
bool SubscribeRecordResponse_Status_IsValid(int value);
const SubscribeRecordResponse_Status SubscribeRecordResponse_Status_Status_MIN = SubscribeRecordResponse_Status_SUCCEED;
const SubscribeRecordResponse_Status SubscribeRecordResponse_Status_Status_MAX = SubscribeRecordResponse_Status_FAILED;
const int SubscribeRecordResponse_Status_Status_ARRAYSIZE = SubscribeRecordResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubscribeRecordResponse_Status_descriptor();
inline const ::std::string& SubscribeRecordResponse_Status_Name(SubscribeRecordResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubscribeRecordResponse_Status_descriptor(), value);
}
inline bool SubscribeRecordResponse_Status_Parse(
    const ::std::string& name, SubscribeRecordResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubscribeRecordResponse_Status>(
    SubscribeRecordResponse_Status_descriptor(), name, value);
}
enum InitSubscriberBrokerRequest_Type {
  InitSubscriberBrokerRequest_Type_TIMESTAMP = 1,
  InitSubscriberBrokerRequest_Type_RECORD_ID = 2
};
bool InitSubscriberBrokerRequest_Type_IsValid(int value);
const InitSubscriberBrokerRequest_Type InitSubscriberBrokerRequest_Type_Type_MIN = InitSubscriberBrokerRequest_Type_TIMESTAMP;
const InitSubscriberBrokerRequest_Type InitSubscriberBrokerRequest_Type_Type_MAX = InitSubscriberBrokerRequest_Type_RECORD_ID;
const int InitSubscriberBrokerRequest_Type_Type_ARRAYSIZE = InitSubscriberBrokerRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* InitSubscriberBrokerRequest_Type_descriptor();
inline const ::std::string& InitSubscriberBrokerRequest_Type_Name(InitSubscriberBrokerRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    InitSubscriberBrokerRequest_Type_descriptor(), value);
}
inline bool InitSubscriberBrokerRequest_Type_Parse(
    const ::std::string& name, InitSubscriberBrokerRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InitSubscriberBrokerRequest_Type>(
    InitSubscriberBrokerRequest_Type_descriptor(), name, value);
}
enum InitSubscriberBrokerRequest_StartRecordType {
  InitSubscriberBrokerRequest_StartRecordType_OLDEST_RECORD = 1,
  InitSubscriberBrokerRequest_StartRecordType_NEWEST_RECORD = 2
};
bool InitSubscriberBrokerRequest_StartRecordType_IsValid(int value);
const InitSubscriberBrokerRequest_StartRecordType InitSubscriberBrokerRequest_StartRecordType_StartRecordType_MIN = InitSubscriberBrokerRequest_StartRecordType_OLDEST_RECORD;
const InitSubscriberBrokerRequest_StartRecordType InitSubscriberBrokerRequest_StartRecordType_StartRecordType_MAX = InitSubscriberBrokerRequest_StartRecordType_NEWEST_RECORD;
const int InitSubscriberBrokerRequest_StartRecordType_StartRecordType_ARRAYSIZE = InitSubscriberBrokerRequest_StartRecordType_StartRecordType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InitSubscriberBrokerRequest_StartRecordType_descriptor();
inline const ::std::string& InitSubscriberBrokerRequest_StartRecordType_Name(InitSubscriberBrokerRequest_StartRecordType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InitSubscriberBrokerRequest_StartRecordType_descriptor(), value);
}
inline bool InitSubscriberBrokerRequest_StartRecordType_Parse(
    const ::std::string& name, InitSubscriberBrokerRequest_StartRecordType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InitSubscriberBrokerRequest_StartRecordType>(
    InitSubscriberBrokerRequest_StartRecordType_descriptor(), name, value);
}
enum InitSubscriberBrokerResponse_Status {
  InitSubscriberBrokerResponse_Status_SUCCEED = 0,
  InitSubscriberBrokerResponse_Status_FAILED = 1,
  InitSubscriberBrokerResponse_Status_STARTING = 2
};
bool InitSubscriberBrokerResponse_Status_IsValid(int value);
const InitSubscriberBrokerResponse_Status InitSubscriberBrokerResponse_Status_Status_MIN = InitSubscriberBrokerResponse_Status_SUCCEED;
const InitSubscriberBrokerResponse_Status InitSubscriberBrokerResponse_Status_Status_MAX = InitSubscriberBrokerResponse_Status_STARTING;
const int InitSubscriberBrokerResponse_Status_Status_ARRAYSIZE = InitSubscriberBrokerResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* InitSubscriberBrokerResponse_Status_descriptor();
inline const ::std::string& InitSubscriberBrokerResponse_Status_Name(InitSubscriberBrokerResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    InitSubscriberBrokerResponse_Status_descriptor(), value);
}
inline bool InitSubscriberBrokerResponse_Status_Parse(
    const ::std::string& name, InitSubscriberBrokerResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InitSubscriberBrokerResponse_Status>(
    InitSubscriberBrokerResponse_Status_descriptor(), name, value);
}
enum GetPartitionGroupProgressResponse_Status {
  GetPartitionGroupProgressResponse_Status_SUCCEED = 0,
  GetPartitionGroupProgressResponse_Status_FAILED = 1
};
bool GetPartitionGroupProgressResponse_Status_IsValid(int value);
const GetPartitionGroupProgressResponse_Status GetPartitionGroupProgressResponse_Status_Status_MIN = GetPartitionGroupProgressResponse_Status_SUCCEED;
const GetPartitionGroupProgressResponse_Status GetPartitionGroupProgressResponse_Status_Status_MAX = GetPartitionGroupProgressResponse_Status_FAILED;
const int GetPartitionGroupProgressResponse_Status_Status_ARRAYSIZE = GetPartitionGroupProgressResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetPartitionGroupProgressResponse_Status_descriptor();
inline const ::std::string& GetPartitionGroupProgressResponse_Status_Name(GetPartitionGroupProgressResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetPartitionGroupProgressResponse_Status_descriptor(), value);
}
inline bool GetPartitionGroupProgressResponse_Status_Parse(
    const ::std::string& name, GetPartitionGroupProgressResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetPartitionGroupProgressResponse_Status>(
    GetPartitionGroupProgressResponse_Status_descriptor(), name, value);
}
// ===================================================================

class PbRecordHeader : public ::google::protobuf::Message {
 public:
  PbRecordHeader();
  virtual ~PbRecordHeader();

  PbRecordHeader(const PbRecordHeader& from);

  inline PbRecordHeader& operator=(const PbRecordHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbRecordHeader& default_instance();

  void Swap(PbRecordHeader* other);

  // implements Message ----------------------------------------------

  PbRecordHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbRecordHeader& from);
  void MergeFrom(const PbRecordHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 body_length = 5;
  inline bool has_body_length() const;
  inline void clear_body_length();
  static const int kBodyLengthFieldNumber = 5;
  inline ::google::protobuf::int64 body_length() const;
  inline void set_body_length(::google::protobuf::int64 value);

  // optional int64 record_id = 6;
  inline bool has_record_id() const;
  inline void clear_record_id();
  static const int kRecordIdFieldNumber = 6;
  inline ::google::protobuf::int64 record_id() const;
  inline void set_record_id(::google::protobuf::int64 value);

  // optional int64 timestamp_in_log = 10;
  inline bool has_timestamp_in_log() const;
  inline void clear_timestamp_in_log();
  static const int kTimestampInLogFieldNumber = 10;
  inline ::google::protobuf::int64 timestamp_in_log() const;
  inline void set_timestamp_in_log(::google::protobuf::int64 value);

  // optional int64 timestamp_in_filename = 11;
  inline bool has_timestamp_in_filename() const;
  inline void clear_timestamp_in_filename();
  static const int kTimestampInFilenameFieldNumber = 11;
  inline ::google::protobuf::int64 timestamp_in_filename() const;
  inline void set_timestamp_in_filename(::google::protobuf::int64 value);

  // optional int64 timestamp_when_send = 12;
  inline bool has_timestamp_when_send() const;
  inline void clear_timestamp_when_send();
  static const int kTimestampWhenSendFieldNumber = 12;
  inline ::google::protobuf::int64 timestamp_when_send() const;
  inline void set_timestamp_when_send(::google::protobuf::int64 value);

  // optional int32 partition_id = 19;
  inline bool has_partition_id() const;
  inline void clear_partition_id();
  static const int kPartitionIdFieldNumber = 19;
  inline ::google::protobuf::int32 partition_id() const;
  inline void set_partition_id(::google::protobuf::int32 value);

  // optional string external_checkpoint = 22;
  inline bool has_external_checkpoint() const;
  inline void clear_external_checkpoint();
  static const int kExternalCheckpointFieldNumber = 22;
  inline const ::std::string& external_checkpoint() const;
  inline void set_external_checkpoint(const ::std::string& value);
  inline void set_external_checkpoint(const char* value);
  inline void set_external_checkpoint(const char* value, size_t size);
  inline ::std::string* mutable_external_checkpoint();
  inline ::std::string* release_external_checkpoint();
  inline void set_allocated_external_checkpoint(::std::string* external_checkpoint);

  // @@protoc_insertion_point(class_scope:baidu.minos.PbRecordHeader)
 private:
  inline void set_has_body_length();
  inline void clear_has_body_length();
  inline void set_has_record_id();
  inline void clear_has_record_id();
  inline void set_has_timestamp_in_log();
  inline void clear_has_timestamp_in_log();
  inline void set_has_timestamp_in_filename();
  inline void clear_has_timestamp_in_filename();
  inline void set_has_timestamp_when_send();
  inline void clear_has_timestamp_when_send();
  inline void set_has_partition_id();
  inline void clear_has_partition_id();
  inline void set_has_external_checkpoint();
  inline void clear_has_external_checkpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 body_length_;
  ::google::protobuf::int64 record_id_;
  ::google::protobuf::int64 timestamp_in_log_;
  ::google::protobuf::int64 timestamp_in_filename_;
  ::google::protobuf::int64 timestamp_when_send_;
  ::std::string* external_checkpoint_;
  ::google::protobuf::int32 partition_id_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static PbRecordHeader* default_instance_;
};
// -------------------------------------------------------------------

class PbRecord : public ::google::protobuf::Message {
 public:
  PbRecord();
  virtual ~PbRecord();

  PbRecord(const PbRecord& from);

  inline PbRecord& operator=(const PbRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbRecord& default_instance();

  void Swap(PbRecord* other);

  // implements Message ----------------------------------------------

  PbRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbRecord& from);
  void MergeFrom(const PbRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .baidu.minos.PbRecordHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::baidu::minos::PbRecordHeader& header() const;
  inline ::baidu::minos::PbRecordHeader* mutable_header();
  inline ::baidu::minos::PbRecordHeader* release_header();
  inline void set_allocated_header(::baidu::minos::PbRecordHeader* header);

  // optional bytes body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:baidu.minos.PbRecord)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::baidu::minos::PbRecordHeader* header_;
  ::std::string* body_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static PbRecord* default_instance_;
};
// -------------------------------------------------------------------

class UserAccountMessage : public ::google::protobuf::Message {
 public:
  UserAccountMessage();
  virtual ~UserAccountMessage();

  UserAccountMessage(const UserAccountMessage& from);

  inline UserAccountMessage& operator=(const UserAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAccountMessage& default_instance();

  void Swap(UserAccountMessage* other);

  // implements Message ----------------------------------------------

  UserAccountMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserAccountMessage& from);
  void MergeFrom(const UserAccountMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:baidu.minos.UserAccountMessage)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static UserAccountMessage* default_instance_;
};
// -------------------------------------------------------------------

class BrokerResponse : public ::google::protobuf::Message {
 public:
  BrokerResponse();
  virtual ~BrokerResponse();

  BrokerResponse(const BrokerResponse& from);

  inline BrokerResponse& operator=(const BrokerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BrokerResponse& default_instance();

  void Swap(BrokerResponse* other);

  // implements Message ----------------------------------------------

  BrokerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrokerResponse& from);
  void MergeFrom(const BrokerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BrokerResponse_Status Status;
  static const Status SUCCEED = BrokerResponse_Status_SUCCEED;
  static const Status FAILED = BrokerResponse_Status_FAILED;
  static inline bool Status_IsValid(int value) {
    return BrokerResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    BrokerResponse_Status_Status_MIN;
  static const Status Status_MAX =
    BrokerResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    BrokerResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return BrokerResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return BrokerResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return BrokerResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .baidu.minos.BrokerResponse.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::baidu::minos::BrokerResponse_Status status() const;
  inline void set_status(::baidu::minos::BrokerResponse_Status value);

  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:baidu.minos.BrokerResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_message_;
  int status_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static BrokerResponse* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeRecordRequest : public ::google::protobuf::Message {
 public:
  SubscribeRecordRequest();
  virtual ~SubscribeRecordRequest();

  SubscribeRecordRequest(const SubscribeRecordRequest& from);

  inline SubscribeRecordRequest& operator=(const SubscribeRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeRecordRequest& default_instance();

  void Swap(SubscribeRecordRequest* other);

  // implements Message ----------------------------------------------

  SubscribeRecordRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeRecordRequest& from);
  void MergeFrom(const SubscribeRecordRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 topic_id = 1;
  inline bool has_topic_id() const;
  inline void clear_topic_id();
  static const int kTopicIdFieldNumber = 1;
  inline ::google::protobuf::int32 topic_id() const;
  inline void set_topic_id(::google::protobuf::int32 value);

  // optional int64 partition_group_id = 2;
  inline bool has_partition_group_id() const;
  inline void clear_partition_group_id();
  static const int kPartitionGroupIdFieldNumber = 2;
  inline ::google::protobuf::int64 partition_group_id() const;
  inline void set_partition_group_id(::google::protobuf::int64 value);

  // optional .baidu.minos.UserAccountMessage account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::baidu::minos::UserAccountMessage& account() const;
  inline ::baidu::minos::UserAccountMessage* mutable_account();
  inline ::baidu::minos::UserAccountMessage* release_account();
  inline void set_allocated_account(::baidu::minos::UserAccountMessage* account);

  // optional int64 data_package_id = 4;
  inline bool has_data_package_id() const;
  inline void clear_data_package_id();
  static const int kDataPackageIdFieldNumber = 4;
  inline ::google::protobuf::int64 data_package_id() const;
  inline void set_data_package_id(::google::protobuf::int64 value);

  // optional int32 record_count = 5 [default = 1];
  inline bool has_record_count() const;
  inline void clear_record_count();
  static const int kRecordCountFieldNumber = 5;
  inline ::google::protobuf::int32 record_count() const;
  inline void set_record_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:baidu.minos.SubscribeRecordRequest)
 private:
  inline void set_has_topic_id();
  inline void clear_has_topic_id();
  inline void set_has_partition_group_id();
  inline void clear_has_partition_group_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_data_package_id();
  inline void clear_has_data_package_id();
  inline void set_has_record_count();
  inline void clear_has_record_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 partition_group_id_;
  ::baidu::minos::UserAccountMessage* account_;
  ::google::protobuf::int32 topic_id_;
  ::google::protobuf::int32 record_count_;
  ::google::protobuf::int64 data_package_id_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static SubscribeRecordRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeRecordResponse : public ::google::protobuf::Message {
 public:
  SubscribeRecordResponse();
  virtual ~SubscribeRecordResponse();

  SubscribeRecordResponse(const SubscribeRecordResponse& from);

  inline SubscribeRecordResponse& operator=(const SubscribeRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeRecordResponse& default_instance();

  void Swap(SubscribeRecordResponse* other);

  // implements Message ----------------------------------------------

  SubscribeRecordResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeRecordResponse& from);
  void MergeFrom(const SubscribeRecordResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SubscribeRecordResponse_Status Status;
  static const Status SUCCEED = SubscribeRecordResponse_Status_SUCCEED;
  static const Status NO_DATA_LEFT = SubscribeRecordResponse_Status_NO_DATA_LEFT;
  static const Status RECORD_ID_TOO_SMALL = SubscribeRecordResponse_Status_RECORD_ID_TOO_SMALL;
  static const Status NO_SUCH_PARTITION_GROUP = SubscribeRecordResponse_Status_NO_SUCH_PARTITION_GROUP;
  static const Status FAILED = SubscribeRecordResponse_Status_FAILED;
  static inline bool Status_IsValid(int value) {
    return SubscribeRecordResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    SubscribeRecordResponse_Status_Status_MIN;
  static const Status Status_MAX =
    SubscribeRecordResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    SubscribeRecordResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return SubscribeRecordResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return SubscribeRecordResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return SubscribeRecordResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .baidu.minos.SubscribeRecordResponse.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::baidu::minos::SubscribeRecordResponse_Status status() const;
  inline void set_status(::baidu::minos::SubscribeRecordResponse_Status value);

  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // repeated .baidu.minos.PbRecord data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::baidu::minos::PbRecord& data(int index) const;
  inline ::baidu::minos::PbRecord* mutable_data(int index);
  inline ::baidu::minos::PbRecord* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::baidu::minos::PbRecord >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::baidu::minos::PbRecord >*
      mutable_data();

  // optional int64 cur_data_package_id = 4;
  inline bool has_cur_data_package_id() const;
  inline void clear_cur_data_package_id();
  static const int kCurDataPackageIdFieldNumber = 4;
  inline ::google::protobuf::int64 cur_data_package_id() const;
  inline void set_cur_data_package_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:baidu.minos.SubscribeRecordResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_cur_data_package_id();
  inline void clear_has_cur_data_package_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_message_;
  ::google::protobuf::RepeatedPtrField< ::baidu::minos::PbRecord > data_;
  ::google::protobuf::int64 cur_data_package_id_;
  int status_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static SubscribeRecordResponse* default_instance_;
};
// -------------------------------------------------------------------

class InitSubscriberBrokerRequest : public ::google::protobuf::Message {
 public:
  InitSubscriberBrokerRequest();
  virtual ~InitSubscriberBrokerRequest();

  InitSubscriberBrokerRequest(const InitSubscriberBrokerRequest& from);

  inline InitSubscriberBrokerRequest& operator=(const InitSubscriberBrokerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitSubscriberBrokerRequest& default_instance();

  void Swap(InitSubscriberBrokerRequest* other);

  // implements Message ----------------------------------------------

  InitSubscriberBrokerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitSubscriberBrokerRequest& from);
  void MergeFrom(const InitSubscriberBrokerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InitSubscriberBrokerRequest_Type Type;
  static const Type TIMESTAMP = InitSubscriberBrokerRequest_Type_TIMESTAMP;
  static const Type RECORD_ID = InitSubscriberBrokerRequest_Type_RECORD_ID;
  static inline bool Type_IsValid(int value) {
    return InitSubscriberBrokerRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    InitSubscriberBrokerRequest_Type_Type_MIN;
  static const Type Type_MAX =
    InitSubscriberBrokerRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    InitSubscriberBrokerRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return InitSubscriberBrokerRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return InitSubscriberBrokerRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return InitSubscriberBrokerRequest_Type_Parse(name, value);
  }

  typedef InitSubscriberBrokerRequest_StartRecordType StartRecordType;
  static const StartRecordType OLDEST_RECORD = InitSubscriberBrokerRequest_StartRecordType_OLDEST_RECORD;
  static const StartRecordType NEWEST_RECORD = InitSubscriberBrokerRequest_StartRecordType_NEWEST_RECORD;
  static inline bool StartRecordType_IsValid(int value) {
    return InitSubscriberBrokerRequest_StartRecordType_IsValid(value);
  }
  static const StartRecordType StartRecordType_MIN =
    InitSubscriberBrokerRequest_StartRecordType_StartRecordType_MIN;
  static const StartRecordType StartRecordType_MAX =
    InitSubscriberBrokerRequest_StartRecordType_StartRecordType_MAX;
  static const int StartRecordType_ARRAYSIZE =
    InitSubscriberBrokerRequest_StartRecordType_StartRecordType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StartRecordType_descriptor() {
    return InitSubscriberBrokerRequest_StartRecordType_descriptor();
  }
  static inline const ::std::string& StartRecordType_Name(StartRecordType value) {
    return InitSubscriberBrokerRequest_StartRecordType_Name(value);
  }
  static inline bool StartRecordType_Parse(const ::std::string& name,
      StartRecordType* value) {
    return InitSubscriberBrokerRequest_StartRecordType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .baidu.minos.InitSubscriberBrokerRequest.Type type = 1 [default = TIMESTAMP];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::baidu::minos::InitSubscriberBrokerRequest_Type type() const;
  inline void set_type(::baidu::minos::InitSubscriberBrokerRequest_Type value);

  // optional int32 topic_id = 2;
  inline bool has_topic_id() const;
  inline void clear_topic_id();
  static const int kTopicIdFieldNumber = 2;
  inline ::google::protobuf::int32 topic_id() const;
  inline void set_topic_id(::google::protobuf::int32 value);

  // optional int64 partition_group_id = 3;
  inline bool has_partition_group_id() const;
  inline void clear_partition_group_id();
  static const int kPartitionGroupIdFieldNumber = 3;
  inline ::google::protobuf::int64 partition_group_id() const;
  inline void set_partition_group_id(::google::protobuf::int64 value);

  // optional bool need_progress = 4 [default = true];
  inline bool has_need_progress() const;
  inline void clear_need_progress();
  static const int kNeedProgressFieldNumber = 4;
  inline bool need_progress() const;
  inline void set_need_progress(bool value);

  // optional .baidu.minos.UserAccountMessage account = 5;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 5;
  inline const ::baidu::minos::UserAccountMessage& account() const;
  inline ::baidu::minos::UserAccountMessage* mutable_account();
  inline ::baidu::minos::UserAccountMessage* release_account();
  inline void set_allocated_account(::baidu::minos::UserAccountMessage* account);

  // optional .baidu.minos.InitSubscriberBrokerRequest.StartRecordType start_record_type = 6 [default = NEWEST_RECORD];
  inline bool has_start_record_type() const;
  inline void clear_start_record_type();
  static const int kStartRecordTypeFieldNumber = 6;
  inline ::baidu::minos::InitSubscriberBrokerRequest_StartRecordType start_record_type() const;
  inline void set_start_record_type(::baidu::minos::InitSubscriberBrokerRequest_StartRecordType value);

  // optional int64 start_timestamp = 7;
  inline bool has_start_timestamp() const;
  inline void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 7;
  inline ::google::protobuf::int64 start_timestamp() const;
  inline void set_start_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:baidu.minos.InitSubscriberBrokerRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_topic_id();
  inline void clear_has_topic_id();
  inline void set_has_partition_group_id();
  inline void clear_has_partition_group_id();
  inline void set_has_need_progress();
  inline void clear_has_need_progress();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_start_record_type();
  inline void clear_has_start_record_type();
  inline void set_has_start_timestamp();
  inline void clear_has_start_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::int32 topic_id_;
  ::google::protobuf::int64 partition_group_id_;
  ::baidu::minos::UserAccountMessage* account_;
  bool need_progress_;
  int start_record_type_;
  ::google::protobuf::int64 start_timestamp_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static InitSubscriberBrokerRequest* default_instance_;
};
// -------------------------------------------------------------------

class InitSubscriberBrokerResponse : public ::google::protobuf::Message {
 public:
  InitSubscriberBrokerResponse();
  virtual ~InitSubscriberBrokerResponse();

  InitSubscriberBrokerResponse(const InitSubscriberBrokerResponse& from);

  inline InitSubscriberBrokerResponse& operator=(const InitSubscriberBrokerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitSubscriberBrokerResponse& default_instance();

  void Swap(InitSubscriberBrokerResponse* other);

  // implements Message ----------------------------------------------

  InitSubscriberBrokerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitSubscriberBrokerResponse& from);
  void MergeFrom(const InitSubscriberBrokerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InitSubscriberBrokerResponse_Status Status;
  static const Status SUCCEED = InitSubscriberBrokerResponse_Status_SUCCEED;
  static const Status FAILED = InitSubscriberBrokerResponse_Status_FAILED;
  static const Status STARTING = InitSubscriberBrokerResponse_Status_STARTING;
  static inline bool Status_IsValid(int value) {
    return InitSubscriberBrokerResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    InitSubscriberBrokerResponse_Status_Status_MIN;
  static const Status Status_MAX =
    InitSubscriberBrokerResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    InitSubscriberBrokerResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return InitSubscriberBrokerResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return InitSubscriberBrokerResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return InitSubscriberBrokerResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .baidu.minos.InitSubscriberBrokerResponse.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::baidu::minos::InitSubscriberBrokerResponse_Status status() const;
  inline void set_status(::baidu::minos::InitSubscriberBrokerResponse_Status value);

  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:baidu.minos.InitSubscriberBrokerResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_message_;
  int status_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static InitSubscriberBrokerResponse* default_instance_;
};
// -------------------------------------------------------------------

class UninitSubscriberBrokerRequest : public ::google::protobuf::Message {
 public:
  UninitSubscriberBrokerRequest();
  virtual ~UninitSubscriberBrokerRequest();

  UninitSubscriberBrokerRequest(const UninitSubscriberBrokerRequest& from);

  inline UninitSubscriberBrokerRequest& operator=(const UninitSubscriberBrokerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UninitSubscriberBrokerRequest& default_instance();

  void Swap(UninitSubscriberBrokerRequest* other);

  // implements Message ----------------------------------------------

  UninitSubscriberBrokerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UninitSubscriberBrokerRequest& from);
  void MergeFrom(const UninitSubscriberBrokerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 topic_id = 1;
  inline bool has_topic_id() const;
  inline void clear_topic_id();
  static const int kTopicIdFieldNumber = 1;
  inline ::google::protobuf::int32 topic_id() const;
  inline void set_topic_id(::google::protobuf::int32 value);

  // optional int64 partition_group_id = 2;
  inline bool has_partition_group_id() const;
  inline void clear_partition_group_id();
  static const int kPartitionGroupIdFieldNumber = 2;
  inline ::google::protobuf::int64 partition_group_id() const;
  inline void set_partition_group_id(::google::protobuf::int64 value);

  // optional .baidu.minos.UserAccountMessage account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::baidu::minos::UserAccountMessage& account() const;
  inline ::baidu::minos::UserAccountMessage* mutable_account();
  inline ::baidu::minos::UserAccountMessage* release_account();
  inline void set_allocated_account(::baidu::minos::UserAccountMessage* account);

  // @@protoc_insertion_point(class_scope:baidu.minos.UninitSubscriberBrokerRequest)
 private:
  inline void set_has_topic_id();
  inline void clear_has_topic_id();
  inline void set_has_partition_group_id();
  inline void clear_has_partition_group_id();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 partition_group_id_;
  ::baidu::minos::UserAccountMessage* account_;
  ::google::protobuf::int32 topic_id_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static UninitSubscriberBrokerRequest* default_instance_;
};
// -------------------------------------------------------------------

class PartitionProgress : public ::google::protobuf::Message {
 public:
  PartitionProgress();
  virtual ~PartitionProgress();

  PartitionProgress(const PartitionProgress& from);

  inline PartitionProgress& operator=(const PartitionProgress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionProgress& default_instance();

  void Swap(PartitionProgress* other);

  // implements Message ----------------------------------------------

  PartitionProgress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartitionProgress& from);
  void MergeFrom(const PartitionProgress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 partition_id = 1;
  inline bool has_partition_id() const;
  inline void clear_partition_id();
  static const int kPartitionIdFieldNumber = 1;
  inline ::google::protobuf::int64 partition_id() const;
  inline void set_partition_id(::google::protobuf::int64 value);

  // optional int64 last_sended_max_record_id = 2;
  inline bool has_last_sended_max_record_id() const;
  inline void clear_last_sended_max_record_id();
  static const int kLastSendedMaxRecordIdFieldNumber = 2;
  inline ::google::protobuf::int64 last_sended_max_record_id() const;
  inline void set_last_sended_max_record_id(::google::protobuf::int64 value);

  // optional int64 cur_sended_max_record_id = 3;
  inline bool has_cur_sended_max_record_id() const;
  inline void clear_cur_sended_max_record_id();
  static const int kCurSendedMaxRecordIdFieldNumber = 3;
  inline ::google::protobuf::int64 cur_sended_max_record_id() const;
  inline void set_cur_sended_max_record_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:baidu.minos.PartitionProgress)
 private:
  inline void set_has_partition_id();
  inline void clear_has_partition_id();
  inline void set_has_last_sended_max_record_id();
  inline void clear_has_last_sended_max_record_id();
  inline void set_has_cur_sended_max_record_id();
  inline void clear_has_cur_sended_max_record_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 partition_id_;
  ::google::protobuf::int64 last_sended_max_record_id_;
  ::google::protobuf::int64 cur_sended_max_record_id_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static PartitionProgress* default_instance_;
};
// -------------------------------------------------------------------

class PartitionGroupProgress : public ::google::protobuf::Message {
 public:
  PartitionGroupProgress();
  virtual ~PartitionGroupProgress();

  PartitionGroupProgress(const PartitionGroupProgress& from);

  inline PartitionGroupProgress& operator=(const PartitionGroupProgress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionGroupProgress& default_instance();

  void Swap(PartitionGroupProgress* other);

  // implements Message ----------------------------------------------

  PartitionGroupProgress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartitionGroupProgress& from);
  void MergeFrom(const PartitionGroupProgress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 topic_id = 1;
  inline bool has_topic_id() const;
  inline void clear_topic_id();
  static const int kTopicIdFieldNumber = 1;
  inline ::google::protobuf::int32 topic_id() const;
  inline void set_topic_id(::google::protobuf::int32 value);

  // optional int32 partition_group_id = 2;
  inline bool has_partition_group_id() const;
  inline void clear_partition_group_id();
  static const int kPartitionGroupIdFieldNumber = 2;
  inline ::google::protobuf::int32 partition_group_id() const;
  inline void set_partition_group_id(::google::protobuf::int32 value);

  // optional int64 cur_data_package_id = 3;
  inline bool has_cur_data_package_id() const;
  inline void clear_cur_data_package_id();
  static const int kCurDataPackageIdFieldNumber = 3;
  inline ::google::protobuf::int64 cur_data_package_id() const;
  inline void set_cur_data_package_id(::google::protobuf::int64 value);

  // optional int64 cur_partition_id = 4;
  inline bool has_cur_partition_id() const;
  inline void clear_cur_partition_id();
  static const int kCurPartitionIdFieldNumber = 4;
  inline ::google::protobuf::int64 cur_partition_id() const;
  inline void set_cur_partition_id(::google::protobuf::int64 value);

  // repeated .baidu.minos.PartitionProgress progress = 5;
  inline int progress_size() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 5;
  inline const ::baidu::minos::PartitionProgress& progress(int index) const;
  inline ::baidu::minos::PartitionProgress* mutable_progress(int index);
  inline ::baidu::minos::PartitionProgress* add_progress();
  inline const ::google::protobuf::RepeatedPtrField< ::baidu::minos::PartitionProgress >&
      progress() const;
  inline ::google::protobuf::RepeatedPtrField< ::baidu::minos::PartitionProgress >*
      mutable_progress();

  // optional .baidu.minos.UserAccountMessage account = 6;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 6;
  inline const ::baidu::minos::UserAccountMessage& account() const;
  inline ::baidu::minos::UserAccountMessage* mutable_account();
  inline ::baidu::minos::UserAccountMessage* release_account();
  inline void set_allocated_account(::baidu::minos::UserAccountMessage* account);

  // @@protoc_insertion_point(class_scope:baidu.minos.PartitionGroupProgress)
 private:
  inline void set_has_topic_id();
  inline void clear_has_topic_id();
  inline void set_has_partition_group_id();
  inline void clear_has_partition_group_id();
  inline void set_has_cur_data_package_id();
  inline void clear_has_cur_data_package_id();
  inline void set_has_cur_partition_id();
  inline void clear_has_cur_partition_id();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 topic_id_;
  ::google::protobuf::int32 partition_group_id_;
  ::google::protobuf::int64 cur_data_package_id_;
  ::google::protobuf::int64 cur_partition_id_;
  ::google::protobuf::RepeatedPtrField< ::baidu::minos::PartitionProgress > progress_;
  ::baidu::minos::UserAccountMessage* account_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static PartitionGroupProgress* default_instance_;
};
// -------------------------------------------------------------------

class SetPartitionGroupProgressRequest : public ::google::protobuf::Message {
 public:
  SetPartitionGroupProgressRequest();
  virtual ~SetPartitionGroupProgressRequest();

  SetPartitionGroupProgressRequest(const SetPartitionGroupProgressRequest& from);

  inline SetPartitionGroupProgressRequest& operator=(const SetPartitionGroupProgressRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPartitionGroupProgressRequest& default_instance();

  void Swap(SetPartitionGroupProgressRequest* other);

  // implements Message ----------------------------------------------

  SetPartitionGroupProgressRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetPartitionGroupProgressRequest& from);
  void MergeFrom(const SetPartitionGroupProgressRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .baidu.minos.PartitionGroupProgress pg_progress = 1;
  inline bool has_pg_progress() const;
  inline void clear_pg_progress();
  static const int kPgProgressFieldNumber = 1;
  inline const ::baidu::minos::PartitionGroupProgress& pg_progress() const;
  inline ::baidu::minos::PartitionGroupProgress* mutable_pg_progress();
  inline ::baidu::minos::PartitionGroupProgress* release_pg_progress();
  inline void set_allocated_pg_progress(::baidu::minos::PartitionGroupProgress* pg_progress);

  // @@protoc_insertion_point(class_scope:baidu.minos.SetPartitionGroupProgressRequest)
 private:
  inline void set_has_pg_progress();
  inline void clear_has_pg_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::baidu::minos::PartitionGroupProgress* pg_progress_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static SetPartitionGroupProgressRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetPartitionGroupProgressRequest : public ::google::protobuf::Message {
 public:
  GetPartitionGroupProgressRequest();
  virtual ~GetPartitionGroupProgressRequest();

  GetPartitionGroupProgressRequest(const GetPartitionGroupProgressRequest& from);

  inline GetPartitionGroupProgressRequest& operator=(const GetPartitionGroupProgressRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPartitionGroupProgressRequest& default_instance();

  void Swap(GetPartitionGroupProgressRequest* other);

  // implements Message ----------------------------------------------

  GetPartitionGroupProgressRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPartitionGroupProgressRequest& from);
  void MergeFrom(const GetPartitionGroupProgressRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 topic_id = 1;
  inline bool has_topic_id() const;
  inline void clear_topic_id();
  static const int kTopicIdFieldNumber = 1;
  inline ::google::protobuf::int32 topic_id() const;
  inline void set_topic_id(::google::protobuf::int32 value);

  // optional int64 partition_group_id = 2;
  inline bool has_partition_group_id() const;
  inline void clear_partition_group_id();
  static const int kPartitionGroupIdFieldNumber = 2;
  inline ::google::protobuf::int64 partition_group_id() const;
  inline void set_partition_group_id(::google::protobuf::int64 value);

  // optional .baidu.minos.UserAccountMessage account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::baidu::minos::UserAccountMessage& account() const;
  inline ::baidu::minos::UserAccountMessage* mutable_account();
  inline ::baidu::minos::UserAccountMessage* release_account();
  inline void set_allocated_account(::baidu::minos::UserAccountMessage* account);

  // @@protoc_insertion_point(class_scope:baidu.minos.GetPartitionGroupProgressRequest)
 private:
  inline void set_has_topic_id();
  inline void clear_has_topic_id();
  inline void set_has_partition_group_id();
  inline void clear_has_partition_group_id();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 partition_group_id_;
  ::baidu::minos::UserAccountMessage* account_;
  ::google::protobuf::int32 topic_id_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static GetPartitionGroupProgressRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetPartitionGroupProgressResponse : public ::google::protobuf::Message {
 public:
  GetPartitionGroupProgressResponse();
  virtual ~GetPartitionGroupProgressResponse();

  GetPartitionGroupProgressResponse(const GetPartitionGroupProgressResponse& from);

  inline GetPartitionGroupProgressResponse& operator=(const GetPartitionGroupProgressResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPartitionGroupProgressResponse& default_instance();

  void Swap(GetPartitionGroupProgressResponse* other);

  // implements Message ----------------------------------------------

  GetPartitionGroupProgressResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPartitionGroupProgressResponse& from);
  void MergeFrom(const GetPartitionGroupProgressResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetPartitionGroupProgressResponse_Status Status;
  static const Status SUCCEED = GetPartitionGroupProgressResponse_Status_SUCCEED;
  static const Status FAILED = GetPartitionGroupProgressResponse_Status_FAILED;
  static inline bool Status_IsValid(int value) {
    return GetPartitionGroupProgressResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    GetPartitionGroupProgressResponse_Status_Status_MIN;
  static const Status Status_MAX =
    GetPartitionGroupProgressResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    GetPartitionGroupProgressResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return GetPartitionGroupProgressResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return GetPartitionGroupProgressResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return GetPartitionGroupProgressResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .baidu.minos.GetPartitionGroupProgressResponse.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::baidu::minos::GetPartitionGroupProgressResponse_Status status() const;
  inline void set_status(::baidu::minos::GetPartitionGroupProgressResponse_Status value);

  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // optional .baidu.minos.PartitionGroupProgress pg_progress = 3;
  inline bool has_pg_progress() const;
  inline void clear_pg_progress();
  static const int kPgProgressFieldNumber = 3;
  inline const ::baidu::minos::PartitionGroupProgress& pg_progress() const;
  inline ::baidu::minos::PartitionGroupProgress* mutable_pg_progress();
  inline ::baidu::minos::PartitionGroupProgress* release_pg_progress();
  inline void set_allocated_pg_progress(::baidu::minos::PartitionGroupProgress* pg_progress);

  // @@protoc_insertion_point(class_scope:baidu.minos.GetPartitionGroupProgressResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_pg_progress();
  inline void clear_has_pg_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_message_;
  ::baidu::minos::PartitionGroupProgress* pg_progress_;
  int status_;
  friend void  protobuf_AddDesc_minos_2eproto();
  friend void protobuf_AssignDesc_minos_2eproto();
  friend void protobuf_ShutdownFile_minos_2eproto();

  void InitAsDefaultInstance();
  static GetPartitionGroupProgressResponse* default_instance_;
};
// ===================================================================

class BrokerService_Stub;

class BrokerService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline BrokerService() {};
 public:
  virtual ~BrokerService();

  typedef BrokerService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void init_subscriber(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::InitSubscriberBrokerRequest* request,
                       ::baidu::minos::InitSubscriberBrokerResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void uninit_subscriber(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::UninitSubscriberBrokerRequest* request,
                       ::baidu::minos::BrokerResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void set_partition_group_progress(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::SetPartitionGroupProgressRequest* request,
                       ::baidu::minos::BrokerResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void get_partition_group_progress(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::GetPartitionGroupProgressRequest* request,
                       ::baidu::minos::GetPartitionGroupProgressResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void subscribe_record(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::SubscribeRecordRequest* request,
                       ::baidu::minos::SubscribeRecordResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(BrokerService);
};

class BrokerService_Stub : public BrokerService {
 public:
  BrokerService_Stub(::google::protobuf::RpcChannel* channel);
  BrokerService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~BrokerService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements BrokerService ------------------------------------------

  void init_subscriber(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::InitSubscriberBrokerRequest* request,
                       ::baidu::minos::InitSubscriberBrokerResponse* response,
                       ::google::protobuf::Closure* done);
  void uninit_subscriber(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::UninitSubscriberBrokerRequest* request,
                       ::baidu::minos::BrokerResponse* response,
                       ::google::protobuf::Closure* done);
  void set_partition_group_progress(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::SetPartitionGroupProgressRequest* request,
                       ::baidu::minos::BrokerResponse* response,
                       ::google::protobuf::Closure* done);
  void get_partition_group_progress(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::GetPartitionGroupProgressRequest* request,
                       ::baidu::minos::GetPartitionGroupProgressResponse* response,
                       ::google::protobuf::Closure* done);
  void subscribe_record(::google::protobuf::RpcController* controller,
                       const ::baidu::minos::SubscribeRecordRequest* request,
                       ::baidu::minos::SubscribeRecordResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(BrokerService_Stub);
};


// ===================================================================


// ===================================================================

// PbRecordHeader

// optional int64 body_length = 5;
inline bool PbRecordHeader::has_body_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbRecordHeader::set_has_body_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbRecordHeader::clear_has_body_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbRecordHeader::clear_body_length() {
  body_length_ = GOOGLE_LONGLONG(0);
  clear_has_body_length();
}
inline ::google::protobuf::int64 PbRecordHeader::body_length() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecordHeader.body_length)
  return body_length_;
}
inline void PbRecordHeader::set_body_length(::google::protobuf::int64 value) {
  set_has_body_length();
  body_length_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecordHeader.body_length)
}

// optional int64 record_id = 6;
inline bool PbRecordHeader::has_record_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbRecordHeader::set_has_record_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbRecordHeader::clear_has_record_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbRecordHeader::clear_record_id() {
  record_id_ = GOOGLE_LONGLONG(0);
  clear_has_record_id();
}
inline ::google::protobuf::int64 PbRecordHeader::record_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecordHeader.record_id)
  return record_id_;
}
inline void PbRecordHeader::set_record_id(::google::protobuf::int64 value) {
  set_has_record_id();
  record_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecordHeader.record_id)
}

// optional int64 timestamp_in_log = 10;
inline bool PbRecordHeader::has_timestamp_in_log() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbRecordHeader::set_has_timestamp_in_log() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbRecordHeader::clear_has_timestamp_in_log() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbRecordHeader::clear_timestamp_in_log() {
  timestamp_in_log_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_in_log();
}
inline ::google::protobuf::int64 PbRecordHeader::timestamp_in_log() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecordHeader.timestamp_in_log)
  return timestamp_in_log_;
}
inline void PbRecordHeader::set_timestamp_in_log(::google::protobuf::int64 value) {
  set_has_timestamp_in_log();
  timestamp_in_log_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecordHeader.timestamp_in_log)
}

// optional int64 timestamp_in_filename = 11;
inline bool PbRecordHeader::has_timestamp_in_filename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbRecordHeader::set_has_timestamp_in_filename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbRecordHeader::clear_has_timestamp_in_filename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbRecordHeader::clear_timestamp_in_filename() {
  timestamp_in_filename_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_in_filename();
}
inline ::google::protobuf::int64 PbRecordHeader::timestamp_in_filename() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecordHeader.timestamp_in_filename)
  return timestamp_in_filename_;
}
inline void PbRecordHeader::set_timestamp_in_filename(::google::protobuf::int64 value) {
  set_has_timestamp_in_filename();
  timestamp_in_filename_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecordHeader.timestamp_in_filename)
}

// optional int64 timestamp_when_send = 12;
inline bool PbRecordHeader::has_timestamp_when_send() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbRecordHeader::set_has_timestamp_when_send() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbRecordHeader::clear_has_timestamp_when_send() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbRecordHeader::clear_timestamp_when_send() {
  timestamp_when_send_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_when_send();
}
inline ::google::protobuf::int64 PbRecordHeader::timestamp_when_send() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecordHeader.timestamp_when_send)
  return timestamp_when_send_;
}
inline void PbRecordHeader::set_timestamp_when_send(::google::protobuf::int64 value) {
  set_has_timestamp_when_send();
  timestamp_when_send_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecordHeader.timestamp_when_send)
}

// optional int32 partition_id = 19;
inline bool PbRecordHeader::has_partition_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbRecordHeader::set_has_partition_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbRecordHeader::clear_has_partition_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbRecordHeader::clear_partition_id() {
  partition_id_ = 0;
  clear_has_partition_id();
}
inline ::google::protobuf::int32 PbRecordHeader::partition_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecordHeader.partition_id)
  return partition_id_;
}
inline void PbRecordHeader::set_partition_id(::google::protobuf::int32 value) {
  set_has_partition_id();
  partition_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecordHeader.partition_id)
}

// optional string external_checkpoint = 22;
inline bool PbRecordHeader::has_external_checkpoint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbRecordHeader::set_has_external_checkpoint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbRecordHeader::clear_has_external_checkpoint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbRecordHeader::clear_external_checkpoint() {
  if (external_checkpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_checkpoint_->clear();
  }
  clear_has_external_checkpoint();
}
inline const ::std::string& PbRecordHeader::external_checkpoint() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecordHeader.external_checkpoint)
  return *external_checkpoint_;
}
inline void PbRecordHeader::set_external_checkpoint(const ::std::string& value) {
  set_has_external_checkpoint();
  if (external_checkpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_checkpoint_ = new ::std::string;
  }
  external_checkpoint_->assign(value);
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecordHeader.external_checkpoint)
}
inline void PbRecordHeader::set_external_checkpoint(const char* value) {
  set_has_external_checkpoint();
  if (external_checkpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_checkpoint_ = new ::std::string;
  }
  external_checkpoint_->assign(value);
  // @@protoc_insertion_point(field_set_char:baidu.minos.PbRecordHeader.external_checkpoint)
}
inline void PbRecordHeader::set_external_checkpoint(const char* value, size_t size) {
  set_has_external_checkpoint();
  if (external_checkpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_checkpoint_ = new ::std::string;
  }
  external_checkpoint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baidu.minos.PbRecordHeader.external_checkpoint)
}
inline ::std::string* PbRecordHeader::mutable_external_checkpoint() {
  set_has_external_checkpoint();
  if (external_checkpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_checkpoint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:baidu.minos.PbRecordHeader.external_checkpoint)
  return external_checkpoint_;
}
inline ::std::string* PbRecordHeader::release_external_checkpoint() {
  clear_has_external_checkpoint();
  if (external_checkpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = external_checkpoint_;
    external_checkpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PbRecordHeader::set_allocated_external_checkpoint(::std::string* external_checkpoint) {
  if (external_checkpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete external_checkpoint_;
  }
  if (external_checkpoint) {
    set_has_external_checkpoint();
    external_checkpoint_ = external_checkpoint;
  } else {
    clear_has_external_checkpoint();
    external_checkpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.PbRecordHeader.external_checkpoint)
}

// -------------------------------------------------------------------

// PbRecord

// optional .baidu.minos.PbRecordHeader header = 1;
inline bool PbRecord::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbRecord::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbRecord::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbRecord::clear_header() {
  if (header_ != NULL) header_->::baidu::minos::PbRecordHeader::Clear();
  clear_has_header();
}
inline const ::baidu::minos::PbRecordHeader& PbRecord::header() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecord.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::baidu::minos::PbRecordHeader* PbRecord::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::baidu::minos::PbRecordHeader;
  // @@protoc_insertion_point(field_mutable:baidu.minos.PbRecord.header)
  return header_;
}
inline ::baidu::minos::PbRecordHeader* PbRecord::release_header() {
  clear_has_header();
  ::baidu::minos::PbRecordHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PbRecord::set_allocated_header(::baidu::minos::PbRecordHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.PbRecord.header)
}

// optional bytes body = 2;
inline bool PbRecord::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbRecord::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbRecord::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbRecord::clear_body() {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& PbRecord::body() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PbRecord.body)
  return *body_;
}
inline void PbRecord::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set:baidu.minos.PbRecord.body)
}
inline void PbRecord::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set_char:baidu.minos.PbRecord.body)
}
inline void PbRecord::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baidu.minos.PbRecord.body)
}
inline ::std::string* PbRecord::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:baidu.minos.PbRecord.body)
  return body_;
}
inline ::std::string* PbRecord::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PbRecord::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.PbRecord.body)
}

// -------------------------------------------------------------------

// UserAccountMessage

// optional string token = 1;
inline bool UserAccountMessage::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserAccountMessage::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserAccountMessage::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserAccountMessage::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserAccountMessage::token() const {
  // @@protoc_insertion_point(field_get:baidu.minos.UserAccountMessage.token)
  return *token_;
}
inline void UserAccountMessage::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:baidu.minos.UserAccountMessage.token)
}
inline void UserAccountMessage::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:baidu.minos.UserAccountMessage.token)
}
inline void UserAccountMessage::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baidu.minos.UserAccountMessage.token)
}
inline ::std::string* UserAccountMessage::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:baidu.minos.UserAccountMessage.token)
  return token_;
}
inline ::std::string* UserAccountMessage::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserAccountMessage::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.UserAccountMessage.token)
}

// -------------------------------------------------------------------

// BrokerResponse

// optional .baidu.minos.BrokerResponse.Status status = 1;
inline bool BrokerResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrokerResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrokerResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrokerResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::baidu::minos::BrokerResponse_Status BrokerResponse::status() const {
  // @@protoc_insertion_point(field_get:baidu.minos.BrokerResponse.status)
  return static_cast< ::baidu::minos::BrokerResponse_Status >(status_);
}
inline void BrokerResponse::set_status(::baidu::minos::BrokerResponse_Status value) {
  assert(::baidu::minos::BrokerResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.BrokerResponse.status)
}

// optional string error_message = 2;
inline bool BrokerResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrokerResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrokerResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrokerResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& BrokerResponse::error_message() const {
  // @@protoc_insertion_point(field_get:baidu.minos.BrokerResponse.error_message)
  return *error_message_;
}
inline void BrokerResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set:baidu.minos.BrokerResponse.error_message)
}
inline void BrokerResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:baidu.minos.BrokerResponse.error_message)
}
inline void BrokerResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baidu.minos.BrokerResponse.error_message)
}
inline ::std::string* BrokerResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:baidu.minos.BrokerResponse.error_message)
  return error_message_;
}
inline ::std::string* BrokerResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BrokerResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.BrokerResponse.error_message)
}

// -------------------------------------------------------------------

// SubscribeRecordRequest

// optional int32 topic_id = 1;
inline bool SubscribeRecordRequest::has_topic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeRecordRequest::set_has_topic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeRecordRequest::clear_has_topic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeRecordRequest::clear_topic_id() {
  topic_id_ = 0;
  clear_has_topic_id();
}
inline ::google::protobuf::int32 SubscribeRecordRequest::topic_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordRequest.topic_id)
  return topic_id_;
}
inline void SubscribeRecordRequest::set_topic_id(::google::protobuf::int32 value) {
  set_has_topic_id();
  topic_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.SubscribeRecordRequest.topic_id)
}

// optional int64 partition_group_id = 2;
inline bool SubscribeRecordRequest::has_partition_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscribeRecordRequest::set_has_partition_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscribeRecordRequest::clear_has_partition_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscribeRecordRequest::clear_partition_group_id() {
  partition_group_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_group_id();
}
inline ::google::protobuf::int64 SubscribeRecordRequest::partition_group_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordRequest.partition_group_id)
  return partition_group_id_;
}
inline void SubscribeRecordRequest::set_partition_group_id(::google::protobuf::int64 value) {
  set_has_partition_group_id();
  partition_group_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.SubscribeRecordRequest.partition_group_id)
}

// optional .baidu.minos.UserAccountMessage account = 3;
inline bool SubscribeRecordRequest::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubscribeRecordRequest::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubscribeRecordRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubscribeRecordRequest::clear_account() {
  if (account_ != NULL) account_->::baidu::minos::UserAccountMessage::Clear();
  clear_has_account();
}
inline const ::baidu::minos::UserAccountMessage& SubscribeRecordRequest::account() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordRequest.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::baidu::minos::UserAccountMessage* SubscribeRecordRequest::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::baidu::minos::UserAccountMessage;
  // @@protoc_insertion_point(field_mutable:baidu.minos.SubscribeRecordRequest.account)
  return account_;
}
inline ::baidu::minos::UserAccountMessage* SubscribeRecordRequest::release_account() {
  clear_has_account();
  ::baidu::minos::UserAccountMessage* temp = account_;
  account_ = NULL;
  return temp;
}
inline void SubscribeRecordRequest::set_allocated_account(::baidu::minos::UserAccountMessage* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.SubscribeRecordRequest.account)
}

// optional int64 data_package_id = 4;
inline bool SubscribeRecordRequest::has_data_package_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubscribeRecordRequest::set_has_data_package_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubscribeRecordRequest::clear_has_data_package_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubscribeRecordRequest::clear_data_package_id() {
  data_package_id_ = GOOGLE_LONGLONG(0);
  clear_has_data_package_id();
}
inline ::google::protobuf::int64 SubscribeRecordRequest::data_package_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordRequest.data_package_id)
  return data_package_id_;
}
inline void SubscribeRecordRequest::set_data_package_id(::google::protobuf::int64 value) {
  set_has_data_package_id();
  data_package_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.SubscribeRecordRequest.data_package_id)
}

// optional int32 record_count = 5 [default = 1];
inline bool SubscribeRecordRequest::has_record_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubscribeRecordRequest::set_has_record_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubscribeRecordRequest::clear_has_record_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubscribeRecordRequest::clear_record_count() {
  record_count_ = 1;
  clear_has_record_count();
}
inline ::google::protobuf::int32 SubscribeRecordRequest::record_count() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordRequest.record_count)
  return record_count_;
}
inline void SubscribeRecordRequest::set_record_count(::google::protobuf::int32 value) {
  set_has_record_count();
  record_count_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.SubscribeRecordRequest.record_count)
}

// -------------------------------------------------------------------

// SubscribeRecordResponse

// required .baidu.minos.SubscribeRecordResponse.Status status = 1;
inline bool SubscribeRecordResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeRecordResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeRecordResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeRecordResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::baidu::minos::SubscribeRecordResponse_Status SubscribeRecordResponse::status() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordResponse.status)
  return static_cast< ::baidu::minos::SubscribeRecordResponse_Status >(status_);
}
inline void SubscribeRecordResponse::set_status(::baidu::minos::SubscribeRecordResponse_Status value) {
  assert(::baidu::minos::SubscribeRecordResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.SubscribeRecordResponse.status)
}

// optional string error_message = 2;
inline bool SubscribeRecordResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscribeRecordResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscribeRecordResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscribeRecordResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& SubscribeRecordResponse::error_message() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordResponse.error_message)
  return *error_message_;
}
inline void SubscribeRecordResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set:baidu.minos.SubscribeRecordResponse.error_message)
}
inline void SubscribeRecordResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:baidu.minos.SubscribeRecordResponse.error_message)
}
inline void SubscribeRecordResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baidu.minos.SubscribeRecordResponse.error_message)
}
inline ::std::string* SubscribeRecordResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:baidu.minos.SubscribeRecordResponse.error_message)
  return error_message_;
}
inline ::std::string* SubscribeRecordResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubscribeRecordResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.SubscribeRecordResponse.error_message)
}

// repeated .baidu.minos.PbRecord data = 3;
inline int SubscribeRecordResponse::data_size() const {
  return data_.size();
}
inline void SubscribeRecordResponse::clear_data() {
  data_.Clear();
}
inline const ::baidu::minos::PbRecord& SubscribeRecordResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordResponse.data)
  return data_.Get(index);
}
inline ::baidu::minos::PbRecord* SubscribeRecordResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:baidu.minos.SubscribeRecordResponse.data)
  return data_.Mutable(index);
}
inline ::baidu::minos::PbRecord* SubscribeRecordResponse::add_data() {
  // @@protoc_insertion_point(field_add:baidu.minos.SubscribeRecordResponse.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::baidu::minos::PbRecord >&
SubscribeRecordResponse::data() const {
  // @@protoc_insertion_point(field_list:baidu.minos.SubscribeRecordResponse.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::baidu::minos::PbRecord >*
SubscribeRecordResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:baidu.minos.SubscribeRecordResponse.data)
  return &data_;
}

// optional int64 cur_data_package_id = 4;
inline bool SubscribeRecordResponse::has_cur_data_package_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubscribeRecordResponse::set_has_cur_data_package_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubscribeRecordResponse::clear_has_cur_data_package_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubscribeRecordResponse::clear_cur_data_package_id() {
  cur_data_package_id_ = GOOGLE_LONGLONG(0);
  clear_has_cur_data_package_id();
}
inline ::google::protobuf::int64 SubscribeRecordResponse::cur_data_package_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SubscribeRecordResponse.cur_data_package_id)
  return cur_data_package_id_;
}
inline void SubscribeRecordResponse::set_cur_data_package_id(::google::protobuf::int64 value) {
  set_has_cur_data_package_id();
  cur_data_package_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.SubscribeRecordResponse.cur_data_package_id)
}

// -------------------------------------------------------------------

// InitSubscriberBrokerRequest

// optional .baidu.minos.InitSubscriberBrokerRequest.Type type = 1 [default = TIMESTAMP];
inline bool InitSubscriberBrokerRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitSubscriberBrokerRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitSubscriberBrokerRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitSubscriberBrokerRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::baidu::minos::InitSubscriberBrokerRequest_Type InitSubscriberBrokerRequest::type() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerRequest.type)
  return static_cast< ::baidu::minos::InitSubscriberBrokerRequest_Type >(type_);
}
inline void InitSubscriberBrokerRequest::set_type(::baidu::minos::InitSubscriberBrokerRequest_Type value) {
  assert(::baidu::minos::InitSubscriberBrokerRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerRequest.type)
}

// optional int32 topic_id = 2;
inline bool InitSubscriberBrokerRequest::has_topic_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitSubscriberBrokerRequest::set_has_topic_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitSubscriberBrokerRequest::clear_has_topic_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitSubscriberBrokerRequest::clear_topic_id() {
  topic_id_ = 0;
  clear_has_topic_id();
}
inline ::google::protobuf::int32 InitSubscriberBrokerRequest::topic_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerRequest.topic_id)
  return topic_id_;
}
inline void InitSubscriberBrokerRequest::set_topic_id(::google::protobuf::int32 value) {
  set_has_topic_id();
  topic_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerRequest.topic_id)
}

// optional int64 partition_group_id = 3;
inline bool InitSubscriberBrokerRequest::has_partition_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitSubscriberBrokerRequest::set_has_partition_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitSubscriberBrokerRequest::clear_has_partition_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitSubscriberBrokerRequest::clear_partition_group_id() {
  partition_group_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_group_id();
}
inline ::google::protobuf::int64 InitSubscriberBrokerRequest::partition_group_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerRequest.partition_group_id)
  return partition_group_id_;
}
inline void InitSubscriberBrokerRequest::set_partition_group_id(::google::protobuf::int64 value) {
  set_has_partition_group_id();
  partition_group_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerRequest.partition_group_id)
}

// optional bool need_progress = 4 [default = true];
inline bool InitSubscriberBrokerRequest::has_need_progress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitSubscriberBrokerRequest::set_has_need_progress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitSubscriberBrokerRequest::clear_has_need_progress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitSubscriberBrokerRequest::clear_need_progress() {
  need_progress_ = true;
  clear_has_need_progress();
}
inline bool InitSubscriberBrokerRequest::need_progress() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerRequest.need_progress)
  return need_progress_;
}
inline void InitSubscriberBrokerRequest::set_need_progress(bool value) {
  set_has_need_progress();
  need_progress_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerRequest.need_progress)
}

// optional .baidu.minos.UserAccountMessage account = 5;
inline bool InitSubscriberBrokerRequest::has_account() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitSubscriberBrokerRequest::set_has_account() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitSubscriberBrokerRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitSubscriberBrokerRequest::clear_account() {
  if (account_ != NULL) account_->::baidu::minos::UserAccountMessage::Clear();
  clear_has_account();
}
inline const ::baidu::minos::UserAccountMessage& InitSubscriberBrokerRequest::account() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerRequest.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::baidu::minos::UserAccountMessage* InitSubscriberBrokerRequest::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::baidu::minos::UserAccountMessage;
  // @@protoc_insertion_point(field_mutable:baidu.minos.InitSubscriberBrokerRequest.account)
  return account_;
}
inline ::baidu::minos::UserAccountMessage* InitSubscriberBrokerRequest::release_account() {
  clear_has_account();
  ::baidu::minos::UserAccountMessage* temp = account_;
  account_ = NULL;
  return temp;
}
inline void InitSubscriberBrokerRequest::set_allocated_account(::baidu::minos::UserAccountMessage* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.InitSubscriberBrokerRequest.account)
}

// optional .baidu.minos.InitSubscriberBrokerRequest.StartRecordType start_record_type = 6 [default = NEWEST_RECORD];
inline bool InitSubscriberBrokerRequest::has_start_record_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitSubscriberBrokerRequest::set_has_start_record_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitSubscriberBrokerRequest::clear_has_start_record_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitSubscriberBrokerRequest::clear_start_record_type() {
  start_record_type_ = 2;
  clear_has_start_record_type();
}
inline ::baidu::minos::InitSubscriberBrokerRequest_StartRecordType InitSubscriberBrokerRequest::start_record_type() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerRequest.start_record_type)
  return static_cast< ::baidu::minos::InitSubscriberBrokerRequest_StartRecordType >(start_record_type_);
}
inline void InitSubscriberBrokerRequest::set_start_record_type(::baidu::minos::InitSubscriberBrokerRequest_StartRecordType value) {
  assert(::baidu::minos::InitSubscriberBrokerRequest_StartRecordType_IsValid(value));
  set_has_start_record_type();
  start_record_type_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerRequest.start_record_type)
}

// optional int64 start_timestamp = 7;
inline bool InitSubscriberBrokerRequest::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InitSubscriberBrokerRequest::set_has_start_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InitSubscriberBrokerRequest::clear_has_start_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InitSubscriberBrokerRequest::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_start_timestamp();
}
inline ::google::protobuf::int64 InitSubscriberBrokerRequest::start_timestamp() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerRequest.start_timestamp)
  return start_timestamp_;
}
inline void InitSubscriberBrokerRequest::set_start_timestamp(::google::protobuf::int64 value) {
  set_has_start_timestamp();
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerRequest.start_timestamp)
}

// -------------------------------------------------------------------

// InitSubscriberBrokerResponse

// required .baidu.minos.InitSubscriberBrokerResponse.Status status = 1;
inline bool InitSubscriberBrokerResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitSubscriberBrokerResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitSubscriberBrokerResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitSubscriberBrokerResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::baidu::minos::InitSubscriberBrokerResponse_Status InitSubscriberBrokerResponse::status() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerResponse.status)
  return static_cast< ::baidu::minos::InitSubscriberBrokerResponse_Status >(status_);
}
inline void InitSubscriberBrokerResponse::set_status(::baidu::minos::InitSubscriberBrokerResponse_Status value) {
  assert(::baidu::minos::InitSubscriberBrokerResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerResponse.status)
}

// optional string error_message = 2;
inline bool InitSubscriberBrokerResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitSubscriberBrokerResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitSubscriberBrokerResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitSubscriberBrokerResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& InitSubscriberBrokerResponse::error_message() const {
  // @@protoc_insertion_point(field_get:baidu.minos.InitSubscriberBrokerResponse.error_message)
  return *error_message_;
}
inline void InitSubscriberBrokerResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set:baidu.minos.InitSubscriberBrokerResponse.error_message)
}
inline void InitSubscriberBrokerResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:baidu.minos.InitSubscriberBrokerResponse.error_message)
}
inline void InitSubscriberBrokerResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baidu.minos.InitSubscriberBrokerResponse.error_message)
}
inline ::std::string* InitSubscriberBrokerResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:baidu.minos.InitSubscriberBrokerResponse.error_message)
  return error_message_;
}
inline ::std::string* InitSubscriberBrokerResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitSubscriberBrokerResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.InitSubscriberBrokerResponse.error_message)
}

// -------------------------------------------------------------------

// UninitSubscriberBrokerRequest

// optional int32 topic_id = 1;
inline bool UninitSubscriberBrokerRequest::has_topic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UninitSubscriberBrokerRequest::set_has_topic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UninitSubscriberBrokerRequest::clear_has_topic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UninitSubscriberBrokerRequest::clear_topic_id() {
  topic_id_ = 0;
  clear_has_topic_id();
}
inline ::google::protobuf::int32 UninitSubscriberBrokerRequest::topic_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.UninitSubscriberBrokerRequest.topic_id)
  return topic_id_;
}
inline void UninitSubscriberBrokerRequest::set_topic_id(::google::protobuf::int32 value) {
  set_has_topic_id();
  topic_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.UninitSubscriberBrokerRequest.topic_id)
}

// optional int64 partition_group_id = 2;
inline bool UninitSubscriberBrokerRequest::has_partition_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UninitSubscriberBrokerRequest::set_has_partition_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UninitSubscriberBrokerRequest::clear_has_partition_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UninitSubscriberBrokerRequest::clear_partition_group_id() {
  partition_group_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_group_id();
}
inline ::google::protobuf::int64 UninitSubscriberBrokerRequest::partition_group_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.UninitSubscriberBrokerRequest.partition_group_id)
  return partition_group_id_;
}
inline void UninitSubscriberBrokerRequest::set_partition_group_id(::google::protobuf::int64 value) {
  set_has_partition_group_id();
  partition_group_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.UninitSubscriberBrokerRequest.partition_group_id)
}

// optional .baidu.minos.UserAccountMessage account = 3;
inline bool UninitSubscriberBrokerRequest::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UninitSubscriberBrokerRequest::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UninitSubscriberBrokerRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UninitSubscriberBrokerRequest::clear_account() {
  if (account_ != NULL) account_->::baidu::minos::UserAccountMessage::Clear();
  clear_has_account();
}
inline const ::baidu::minos::UserAccountMessage& UninitSubscriberBrokerRequest::account() const {
  // @@protoc_insertion_point(field_get:baidu.minos.UninitSubscriberBrokerRequest.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::baidu::minos::UserAccountMessage* UninitSubscriberBrokerRequest::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::baidu::minos::UserAccountMessage;
  // @@protoc_insertion_point(field_mutable:baidu.minos.UninitSubscriberBrokerRequest.account)
  return account_;
}
inline ::baidu::minos::UserAccountMessage* UninitSubscriberBrokerRequest::release_account() {
  clear_has_account();
  ::baidu::minos::UserAccountMessage* temp = account_;
  account_ = NULL;
  return temp;
}
inline void UninitSubscriberBrokerRequest::set_allocated_account(::baidu::minos::UserAccountMessage* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.UninitSubscriberBrokerRequest.account)
}

// -------------------------------------------------------------------

// PartitionProgress

// optional int64 partition_id = 1;
inline bool PartitionProgress::has_partition_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionProgress::set_has_partition_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionProgress::clear_has_partition_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionProgress::clear_partition_id() {
  partition_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_id();
}
inline ::google::protobuf::int64 PartitionProgress::partition_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionProgress.partition_id)
  return partition_id_;
}
inline void PartitionProgress::set_partition_id(::google::protobuf::int64 value) {
  set_has_partition_id();
  partition_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PartitionProgress.partition_id)
}

// optional int64 last_sended_max_record_id = 2;
inline bool PartitionProgress::has_last_sended_max_record_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionProgress::set_has_last_sended_max_record_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartitionProgress::clear_has_last_sended_max_record_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartitionProgress::clear_last_sended_max_record_id() {
  last_sended_max_record_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_sended_max_record_id();
}
inline ::google::protobuf::int64 PartitionProgress::last_sended_max_record_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionProgress.last_sended_max_record_id)
  return last_sended_max_record_id_;
}
inline void PartitionProgress::set_last_sended_max_record_id(::google::protobuf::int64 value) {
  set_has_last_sended_max_record_id();
  last_sended_max_record_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PartitionProgress.last_sended_max_record_id)
}

// optional int64 cur_sended_max_record_id = 3;
inline bool PartitionProgress::has_cur_sended_max_record_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitionProgress::set_has_cur_sended_max_record_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PartitionProgress::clear_has_cur_sended_max_record_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PartitionProgress::clear_cur_sended_max_record_id() {
  cur_sended_max_record_id_ = GOOGLE_LONGLONG(0);
  clear_has_cur_sended_max_record_id();
}
inline ::google::protobuf::int64 PartitionProgress::cur_sended_max_record_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionProgress.cur_sended_max_record_id)
  return cur_sended_max_record_id_;
}
inline void PartitionProgress::set_cur_sended_max_record_id(::google::protobuf::int64 value) {
  set_has_cur_sended_max_record_id();
  cur_sended_max_record_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PartitionProgress.cur_sended_max_record_id)
}

// -------------------------------------------------------------------

// PartitionGroupProgress

// optional int32 topic_id = 1;
inline bool PartitionGroupProgress::has_topic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionGroupProgress::set_has_topic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionGroupProgress::clear_has_topic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionGroupProgress::clear_topic_id() {
  topic_id_ = 0;
  clear_has_topic_id();
}
inline ::google::protobuf::int32 PartitionGroupProgress::topic_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionGroupProgress.topic_id)
  return topic_id_;
}
inline void PartitionGroupProgress::set_topic_id(::google::protobuf::int32 value) {
  set_has_topic_id();
  topic_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PartitionGroupProgress.topic_id)
}

// optional int32 partition_group_id = 2;
inline bool PartitionGroupProgress::has_partition_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionGroupProgress::set_has_partition_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartitionGroupProgress::clear_has_partition_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartitionGroupProgress::clear_partition_group_id() {
  partition_group_id_ = 0;
  clear_has_partition_group_id();
}
inline ::google::protobuf::int32 PartitionGroupProgress::partition_group_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionGroupProgress.partition_group_id)
  return partition_group_id_;
}
inline void PartitionGroupProgress::set_partition_group_id(::google::protobuf::int32 value) {
  set_has_partition_group_id();
  partition_group_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PartitionGroupProgress.partition_group_id)
}

// optional int64 cur_data_package_id = 3;
inline bool PartitionGroupProgress::has_cur_data_package_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitionGroupProgress::set_has_cur_data_package_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PartitionGroupProgress::clear_has_cur_data_package_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PartitionGroupProgress::clear_cur_data_package_id() {
  cur_data_package_id_ = GOOGLE_LONGLONG(0);
  clear_has_cur_data_package_id();
}
inline ::google::protobuf::int64 PartitionGroupProgress::cur_data_package_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionGroupProgress.cur_data_package_id)
  return cur_data_package_id_;
}
inline void PartitionGroupProgress::set_cur_data_package_id(::google::protobuf::int64 value) {
  set_has_cur_data_package_id();
  cur_data_package_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PartitionGroupProgress.cur_data_package_id)
}

// optional int64 cur_partition_id = 4;
inline bool PartitionGroupProgress::has_cur_partition_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PartitionGroupProgress::set_has_cur_partition_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PartitionGroupProgress::clear_has_cur_partition_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PartitionGroupProgress::clear_cur_partition_id() {
  cur_partition_id_ = GOOGLE_LONGLONG(0);
  clear_has_cur_partition_id();
}
inline ::google::protobuf::int64 PartitionGroupProgress::cur_partition_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionGroupProgress.cur_partition_id)
  return cur_partition_id_;
}
inline void PartitionGroupProgress::set_cur_partition_id(::google::protobuf::int64 value) {
  set_has_cur_partition_id();
  cur_partition_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.PartitionGroupProgress.cur_partition_id)
}

// repeated .baidu.minos.PartitionProgress progress = 5;
inline int PartitionGroupProgress::progress_size() const {
  return progress_.size();
}
inline void PartitionGroupProgress::clear_progress() {
  progress_.Clear();
}
inline const ::baidu::minos::PartitionProgress& PartitionGroupProgress::progress(int index) const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionGroupProgress.progress)
  return progress_.Get(index);
}
inline ::baidu::minos::PartitionProgress* PartitionGroupProgress::mutable_progress(int index) {
  // @@protoc_insertion_point(field_mutable:baidu.minos.PartitionGroupProgress.progress)
  return progress_.Mutable(index);
}
inline ::baidu::minos::PartitionProgress* PartitionGroupProgress::add_progress() {
  // @@protoc_insertion_point(field_add:baidu.minos.PartitionGroupProgress.progress)
  return progress_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::baidu::minos::PartitionProgress >&
PartitionGroupProgress::progress() const {
  // @@protoc_insertion_point(field_list:baidu.minos.PartitionGroupProgress.progress)
  return progress_;
}
inline ::google::protobuf::RepeatedPtrField< ::baidu::minos::PartitionProgress >*
PartitionGroupProgress::mutable_progress() {
  // @@protoc_insertion_point(field_mutable_list:baidu.minos.PartitionGroupProgress.progress)
  return &progress_;
}

// optional .baidu.minos.UserAccountMessage account = 6;
inline bool PartitionGroupProgress::has_account() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PartitionGroupProgress::set_has_account() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PartitionGroupProgress::clear_has_account() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PartitionGroupProgress::clear_account() {
  if (account_ != NULL) account_->::baidu::minos::UserAccountMessage::Clear();
  clear_has_account();
}
inline const ::baidu::minos::UserAccountMessage& PartitionGroupProgress::account() const {
  // @@protoc_insertion_point(field_get:baidu.minos.PartitionGroupProgress.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::baidu::minos::UserAccountMessage* PartitionGroupProgress::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::baidu::minos::UserAccountMessage;
  // @@protoc_insertion_point(field_mutable:baidu.minos.PartitionGroupProgress.account)
  return account_;
}
inline ::baidu::minos::UserAccountMessage* PartitionGroupProgress::release_account() {
  clear_has_account();
  ::baidu::minos::UserAccountMessage* temp = account_;
  account_ = NULL;
  return temp;
}
inline void PartitionGroupProgress::set_allocated_account(::baidu::minos::UserAccountMessage* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.PartitionGroupProgress.account)
}

// -------------------------------------------------------------------

// SetPartitionGroupProgressRequest

// optional .baidu.minos.PartitionGroupProgress pg_progress = 1;
inline bool SetPartitionGroupProgressRequest::has_pg_progress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPartitionGroupProgressRequest::set_has_pg_progress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPartitionGroupProgressRequest::clear_has_pg_progress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPartitionGroupProgressRequest::clear_pg_progress() {
  if (pg_progress_ != NULL) pg_progress_->::baidu::minos::PartitionGroupProgress::Clear();
  clear_has_pg_progress();
}
inline const ::baidu::minos::PartitionGroupProgress& SetPartitionGroupProgressRequest::pg_progress() const {
  // @@protoc_insertion_point(field_get:baidu.minos.SetPartitionGroupProgressRequest.pg_progress)
  return pg_progress_ != NULL ? *pg_progress_ : *default_instance_->pg_progress_;
}
inline ::baidu::minos::PartitionGroupProgress* SetPartitionGroupProgressRequest::mutable_pg_progress() {
  set_has_pg_progress();
  if (pg_progress_ == NULL) pg_progress_ = new ::baidu::minos::PartitionGroupProgress;
  // @@protoc_insertion_point(field_mutable:baidu.minos.SetPartitionGroupProgressRequest.pg_progress)
  return pg_progress_;
}
inline ::baidu::minos::PartitionGroupProgress* SetPartitionGroupProgressRequest::release_pg_progress() {
  clear_has_pg_progress();
  ::baidu::minos::PartitionGroupProgress* temp = pg_progress_;
  pg_progress_ = NULL;
  return temp;
}
inline void SetPartitionGroupProgressRequest::set_allocated_pg_progress(::baidu::minos::PartitionGroupProgress* pg_progress) {
  delete pg_progress_;
  pg_progress_ = pg_progress;
  if (pg_progress) {
    set_has_pg_progress();
  } else {
    clear_has_pg_progress();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.SetPartitionGroupProgressRequest.pg_progress)
}

// -------------------------------------------------------------------

// GetPartitionGroupProgressRequest

// optional int32 topic_id = 1;
inline bool GetPartitionGroupProgressRequest::has_topic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPartitionGroupProgressRequest::set_has_topic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPartitionGroupProgressRequest::clear_has_topic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPartitionGroupProgressRequest::clear_topic_id() {
  topic_id_ = 0;
  clear_has_topic_id();
}
inline ::google::protobuf::int32 GetPartitionGroupProgressRequest::topic_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.GetPartitionGroupProgressRequest.topic_id)
  return topic_id_;
}
inline void GetPartitionGroupProgressRequest::set_topic_id(::google::protobuf::int32 value) {
  set_has_topic_id();
  topic_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.GetPartitionGroupProgressRequest.topic_id)
}

// optional int64 partition_group_id = 2;
inline bool GetPartitionGroupProgressRequest::has_partition_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPartitionGroupProgressRequest::set_has_partition_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPartitionGroupProgressRequest::clear_has_partition_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPartitionGroupProgressRequest::clear_partition_group_id() {
  partition_group_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_group_id();
}
inline ::google::protobuf::int64 GetPartitionGroupProgressRequest::partition_group_id() const {
  // @@protoc_insertion_point(field_get:baidu.minos.GetPartitionGroupProgressRequest.partition_group_id)
  return partition_group_id_;
}
inline void GetPartitionGroupProgressRequest::set_partition_group_id(::google::protobuf::int64 value) {
  set_has_partition_group_id();
  partition_group_id_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.GetPartitionGroupProgressRequest.partition_group_id)
}

// optional .baidu.minos.UserAccountMessage account = 3;
inline bool GetPartitionGroupProgressRequest::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPartitionGroupProgressRequest::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPartitionGroupProgressRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPartitionGroupProgressRequest::clear_account() {
  if (account_ != NULL) account_->::baidu::minos::UserAccountMessage::Clear();
  clear_has_account();
}
inline const ::baidu::minos::UserAccountMessage& GetPartitionGroupProgressRequest::account() const {
  // @@protoc_insertion_point(field_get:baidu.minos.GetPartitionGroupProgressRequest.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::baidu::minos::UserAccountMessage* GetPartitionGroupProgressRequest::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::baidu::minos::UserAccountMessage;
  // @@protoc_insertion_point(field_mutable:baidu.minos.GetPartitionGroupProgressRequest.account)
  return account_;
}
inline ::baidu::minos::UserAccountMessage* GetPartitionGroupProgressRequest::release_account() {
  clear_has_account();
  ::baidu::minos::UserAccountMessage* temp = account_;
  account_ = NULL;
  return temp;
}
inline void GetPartitionGroupProgressRequest::set_allocated_account(::baidu::minos::UserAccountMessage* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.GetPartitionGroupProgressRequest.account)
}

// -------------------------------------------------------------------

// GetPartitionGroupProgressResponse

// required .baidu.minos.GetPartitionGroupProgressResponse.Status status = 1;
inline bool GetPartitionGroupProgressResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPartitionGroupProgressResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPartitionGroupProgressResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPartitionGroupProgressResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::baidu::minos::GetPartitionGroupProgressResponse_Status GetPartitionGroupProgressResponse::status() const {
  // @@protoc_insertion_point(field_get:baidu.minos.GetPartitionGroupProgressResponse.status)
  return static_cast< ::baidu::minos::GetPartitionGroupProgressResponse_Status >(status_);
}
inline void GetPartitionGroupProgressResponse::set_status(::baidu::minos::GetPartitionGroupProgressResponse_Status value) {
  assert(::baidu::minos::GetPartitionGroupProgressResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:baidu.minos.GetPartitionGroupProgressResponse.status)
}

// optional string error_message = 2;
inline bool GetPartitionGroupProgressResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPartitionGroupProgressResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPartitionGroupProgressResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPartitionGroupProgressResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& GetPartitionGroupProgressResponse::error_message() const {
  // @@protoc_insertion_point(field_get:baidu.minos.GetPartitionGroupProgressResponse.error_message)
  return *error_message_;
}
inline void GetPartitionGroupProgressResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set:baidu.minos.GetPartitionGroupProgressResponse.error_message)
}
inline void GetPartitionGroupProgressResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:baidu.minos.GetPartitionGroupProgressResponse.error_message)
}
inline void GetPartitionGroupProgressResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baidu.minos.GetPartitionGroupProgressResponse.error_message)
}
inline ::std::string* GetPartitionGroupProgressResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:baidu.minos.GetPartitionGroupProgressResponse.error_message)
  return error_message_;
}
inline ::std::string* GetPartitionGroupProgressResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPartitionGroupProgressResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.GetPartitionGroupProgressResponse.error_message)
}

// optional .baidu.minos.PartitionGroupProgress pg_progress = 3;
inline bool GetPartitionGroupProgressResponse::has_pg_progress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPartitionGroupProgressResponse::set_has_pg_progress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPartitionGroupProgressResponse::clear_has_pg_progress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPartitionGroupProgressResponse::clear_pg_progress() {
  if (pg_progress_ != NULL) pg_progress_->::baidu::minos::PartitionGroupProgress::Clear();
  clear_has_pg_progress();
}
inline const ::baidu::minos::PartitionGroupProgress& GetPartitionGroupProgressResponse::pg_progress() const {
  // @@protoc_insertion_point(field_get:baidu.minos.GetPartitionGroupProgressResponse.pg_progress)
  return pg_progress_ != NULL ? *pg_progress_ : *default_instance_->pg_progress_;
}
inline ::baidu::minos::PartitionGroupProgress* GetPartitionGroupProgressResponse::mutable_pg_progress() {
  set_has_pg_progress();
  if (pg_progress_ == NULL) pg_progress_ = new ::baidu::minos::PartitionGroupProgress;
  // @@protoc_insertion_point(field_mutable:baidu.minos.GetPartitionGroupProgressResponse.pg_progress)
  return pg_progress_;
}
inline ::baidu::minos::PartitionGroupProgress* GetPartitionGroupProgressResponse::release_pg_progress() {
  clear_has_pg_progress();
  ::baidu::minos::PartitionGroupProgress* temp = pg_progress_;
  pg_progress_ = NULL;
  return temp;
}
inline void GetPartitionGroupProgressResponse::set_allocated_pg_progress(::baidu::minos::PartitionGroupProgress* pg_progress) {
  delete pg_progress_;
  pg_progress_ = pg_progress;
  if (pg_progress) {
    set_has_pg_progress();
  } else {
    clear_has_pg_progress();
  }
  // @@protoc_insertion_point(field_set_allocated:baidu.minos.GetPartitionGroupProgressResponse.pg_progress)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace minos
}  // namespace baidu

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::baidu::minos::BrokerResponse_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baidu::minos::BrokerResponse_Status>() {
  return ::baidu::minos::BrokerResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::baidu::minos::SubscribeRecordResponse_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baidu::minos::SubscribeRecordResponse_Status>() {
  return ::baidu::minos::SubscribeRecordResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::baidu::minos::InitSubscriberBrokerRequest_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baidu::minos::InitSubscriberBrokerRequest_Type>() {
  return ::baidu::minos::InitSubscriberBrokerRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::baidu::minos::InitSubscriberBrokerRequest_StartRecordType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baidu::minos::InitSubscriberBrokerRequest_StartRecordType>() {
  return ::baidu::minos::InitSubscriberBrokerRequest_StartRecordType_descriptor();
}
template <> struct is_proto_enum< ::baidu::minos::InitSubscriberBrokerResponse_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baidu::minos::InitSubscriberBrokerResponse_Status>() {
  return ::baidu::minos::InitSubscriberBrokerResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::baidu::minos::GetPartitionGroupProgressResponse_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baidu::minos::GetPartitionGroupProgressResponse_Status>() {
  return ::baidu::minos::GetPartitionGroupProgressResponse_Status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_minos_2eproto__INCLUDED
